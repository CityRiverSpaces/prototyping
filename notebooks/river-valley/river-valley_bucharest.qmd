---
title: "River valley delineation"
format: html
---

```{r}
library("ggplot2")
library("sf")
library("terra")
```

# Define a threshold for river valley

In this notebook, the river valley is defined by a maximum elevation gain from the river line along a shortest path. 
```{r}
THRES_ELEVETION_GAIN = 10 # Elevation Gain threshold in meters
```

# River valley delineation for Bucharest waterways

Load input files: raster DEM and multilinestrings representing the waterway:

```{r}
dem <- rast("data/DEM_Bucharest.tif")
river <- st_read("data/CRiSp-data-bucharest.gpkg", layer = "URC-D_dambovita_l_2017") |>
    st_zm(drop = TRUE, what = "ZM")  # drop Z dimension
```


Filter Dem with a low-pass filter. This is applied because of the resisual building elevations in DTM. 
The median of the moving window is taken to replace the center pixel. 
```{r}
dem_filtered <- focal(dem, w=3, fun="median")
```



```{r}
dem_df_filtered <- as.data.frame(dem_filtered, xy=TRUE)  # convert raster to df for plotting

xlim <- c(xmin(dem_filtered), xmax(dem_filtered))
ylim <- c(ymin(dem_filtered), ymax(dem_filtered))

r <- geom_raster(
    data = dem_df_filtered,
    aes(
        x = x,
        y = y,
        fill = focal_median
    )
)
v <- geom_sf(data = river)
ggplot() + r + v + coord_sf(xlim = xlim, ylim= ylim, expand = FALSE)
```


```{r}
dem <- dem_filtered
```


Reproject both DEM and waterway to projected CRS (in m):

```{r}
utm_crs <- 'epsg:32635'
dem_repr <- project(dem, utm_crs, method = "near")
river_repr <- st_transform(river, crs = utm_crs)
```

Compute slope and convert it to percentage:

```{r}
slope_rad <- terrain(dem_repr, v = "slope", unit = "radians")
slope <- tan(slope_rad)
```


```{r}
plot(slope)
```

Set the slope to zero for the pixels overlapping the waterway. These values will be used as "targets" in the calculation of the cost distance:

```{r}
slope_masked <- mask(
    slope,
    ifel(slope <= 1.e-3, NA, 1),
    updatevalue = 1.e-3
)
slope_masked <- mask(
    slope_masked,
    river_repr,
    inverse = TRUE,
    updatevalue = 0,
    touches = TRUE
)
```

Use the `costDist` function from `terra` to compute the cost distance from the target cells (cells with value equal to zero):

```{r}
cd <- costDist(slope_masked, target=0)
```

Visualize the mask generated using a (random) threshold applied to the computed cost distance:

```{r}
plot(cd<2)
```

Load the valley edge used in the previous study and reproject it:

```{r}
st_layers("data/CRiSp-data-bucharest.gpkg")
valley <- st_read("data/CRiSp-data-bucharest.gpkg", layer = "URC-D_valleyedge_mod")
valley_repr <- st_transform(valley, crs = utm_crs)
```

Compare current result with previous valley edge:

```{r}
cd_thres_df <- as.data.frame(cd <= THRES_ELEVETION_GAIN, xy=TRUE)  # convert raster to df for plotting

xlim <- c(xmin(cd), xmax(cd))
ylim <- c(ymin(cd), ymax(cd))

r <- geom_raster(
    data = cd_thres_df,
    aes(
        x = x,
        y = y,
        fill = slope
    )
)
v <- geom_sf(data = valley_repr)
ggplot() + r + v + coord_sf(xlim = xlim, ylim= ylim, expand = FALSE)
```
